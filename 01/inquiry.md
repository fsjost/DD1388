# g++ compiler questions

### Where can you find the manual to g++?
The manual to g++ can be found at [GCC online documentation](https://gcc.gnu.org/onlinedocs/).

### What is the purpose of -Wall and -g, when passed as arguments to g++?
-Wall = Warn all. Turns on (almost) all warnings g++ can tell.
-g = Allows you to emit debugging information for your program, which you can use for debugging with f.e. gdb.

### How can you store the previous mentioned flags in a variable in the makefile?
By defining the flags as "FLAGS = -Wall -g" and then use $(FLAGS).

### Find and write down 4 other arguments to g++ that you think might be useful and write a short motivation why you selected these specific 4 arguments.
1. -o file       - used to get an output file with the name 'file'. Othervise it will save as 'a.out'. Easier to make it tidy.
2. -fsyntax-only - checks code for syntax errors only. Good if you're only interesting in those kind of errors.
3. - I           - specifying a directory afterwards will result in g++ searching for in it if '#include 'file'' is used in program (not if '#include <file>' used.)
4. - -std=c++11  - Will specify which language is standard (in this case c++11).

### What is the difference between an object file, and an executable?
An object file is machine code generated by a compiler from a source code.  (no references to functions et cetera, memory addresses "blank")
The executable file is not to be read by the human, but by the computer.

# Git questions

### What does _git show HEAD~:01/makefile_ show?
Shows the old version (parent) of makefile.

### What does _git show HEAD:01/makefile_ show?
This will show the new version of makefile.

### What would _git show HEAD~~:01/makefile_ show?
This will show the parents parent of the file (i.iei the old old version?)

### What does the ~ in the previous git show commands mean?
It means the parent of the said file.

### Why can you not ommit 01 in the previous commands (i.e. _git show HEAD~:makefile_ instead of _git show HEAD~:01/makefile_)
Because you need to specify in which directory the file 'makefile' is in.

### Sometimes you may need to do a git pull before you can do a git push how can that be?
When two or more people (say, A and B) are working on the same project (same git repo) and A pushes a change on the branch to the repo before B. Then person B needs to do a pull before he is able to push.

### What is the purpose of the _.git_ignore_ file and why should _*.o *.out *.exe_ be in this file when developing C++?
Specifies intentionally untracked files that github should ignore. They are executive files and can be compiled from the .cpp files. Keeping the directories tidy is good.

# Makefile Questions

### If you invoke touch hello.cpp prior to invoking make, how many files were rebuilt.
Only hello.cpp will be rebuilt.

### Why?
Because it is the only file being touched.

### Why do you think make checks the modification timestamp of the relevant files as part of deciding what to do?
Because if a file has only been edited prior the last time of make it is unnecessary to make it again.

### What is the difference between an implicit rule and an explicit rule in a makefile?
*The explicit rules* tell how and when a *file* should be remade. It lists all the files that the targets depend on, call the target, and might also update and create the targets.
*The implicite rules* tells how and when a *class* should be remade, based on their names. Describes hoe a target may or may not depend on a file with similiar name to the target.

### What does _$*_ mean inside a makefile
The stem with which an implicit rule matches. Useful for constructing names of related files.

# Hello World Questions

### What is the purpose of std::cout, std::cerr, and std::clog, respectively?
1. *std::cout*  works as an regular output print to the user. std::cout << "hej"; prints "hej"
2. *std:cerr* works as an error output print to the user. Not buffered.    ("you want to make sure output is printed before continuing")
3. *std:clog* works as logging. Still results in an output.

### How does #include work?
This inclues files other source files into the current source file.

# Debugging Questions

### Why does not powerof return the expected value (16), when invoked with 2 and 4?
Because there is a ;-sign after the for loop-command in the function powerof, which skips the loop.

### Why does not adding_a_decimal output 100000?
Because float is used instead of double. Float will not be precise enough for the numbers (it will cut off the binary code resulting in an error). Using double will give the desired output.

### Describe how weird.out is invoked by echo '3.1415' | ./weird.out
Echoing 3.1415 inserts 3.1415 as y in the main function right under "adding_a_decimal".

### Why does not y compare equal to 3.1415?
Because y is a float and 3.1415 is not (it is a string).

### Is there any difference in behavior if we compare y to 3.1415f, if so; why?
Yes, then it becomes equal. Because, by finishing with the f, you make 3.1415 to a float instead of a string.

### Describe and motivate the recommended method to use when trying to determine if two floating-point values are equal.
By taking their difference (a-b), and see if it is close enough to 0 by, for example, using an epsilon like the one in calculus. If the difference is small enough they are said to be equal.

# unit test questions
### Why is it important to test the boundary conditions of an implementation, especially in the case of count_if_followed_by?
Because it is important to see what happens for these boundaries, to see if it crasher or starts acting weird. If it is known how these 'extreme cases' work every other case is covered.

### Describe how the testcase tests if a pointer is accessing an element outside the range specified
It tests it by defining the range to stop for 3 index. If it would stop for the third index, as one would expect, the result would be 0. But since 'X' is followed by 'G' as the 4th element, and we get the result 1, the conclusion that the pointer IS accessing an element outside the range specified is being made.

# class construction questions
### What constructors are invoked, and when? List the corresponding lines and name the invoked constructor
*They are invoked in this order:*
* Line 32 -> some other constructor
* Line 34 -> copy-constructor
* Line 35 -> copy-constructor
* Line 36 -> default-constructor
* Line 38 -> the assignment operator
* Line 40 -> copy-constructor
* Line 41 -> destructor
* Line 43 -> default-constructor x 5
* Line 44 -> destructor

### Will there be any temporaries created, if so; when?
?? Idk

### What will happen if we try to free a dynamically allocated array through delete p, instead of delete [] p?
I think this question is in the wrong section and should be for bad_plummer and not complex....?

# Valgrind
### valgrind indicates that there is something wrong with complex.cpp; what, and why?
We have a memory leakage of 13 bytes in 1 block. This is due to deleting aa deletes the pointer to aa and leaves 4 elements in the matrix untouched and "lost" from us.

### valgrind indicates that the program suffers from a few problems, which and why?
1. There is a conditional jump or move error when trying the first if-block for an empty v (trying to reach indices that do not exists).
2. There is memory leakage of 60 bytes, due to 3 integers of 4 bytes each are lost in the 5 elements of the v-vector.

### If you comment out the entire if-block in foo, is there any difference in how much memory that is leaked?
There is no difference in the memory leakage, no.

### Why is it that valgrind still issue diagnostics related to memory management
Because even though the if-block never happens, deleting p will still result in deleting only the elements in v but leaving its skeleton behind.
